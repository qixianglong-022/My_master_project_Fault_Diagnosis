import torchimport torch.nn as nnimport numpy as npclass PhysRDLinearCls(nn.Module):    def __init__(self, num_classes=8, seq_len=1024, enc_in=1):        super().__init__()        # 1. 骨干复用 (Backbone)        # 输入是频域谱 [B, 1024, 1]        self.seq_len = seq_len        # RevIN (频域归一化，消除幅值差异)        self.revin = RevIN(enc_in, affine=True)        # 分解 (Decomp) -> 物理含义迁移        # Trend = 宽带包络, Seasonal = 窄带谱峰        self.decomp = SeriesDecomp(kernel_size=25)        # 2. 诊断分支 (Diagnostic Branch)        # 线性层提取特征        self.linear_trend = nn.Linear(seq_len, 128)        self.linear_seasonal = nn.Linear(seq_len, 128)        # 3. 虚拟负载传感器 (Virtual Load Sensor) - MTL        # 从 Trend 特征回归负载 (0, 200, 400)        self.load_head = nn.Sequential(            nn.Linear(128, 64),            nn.ReLU(),            nn.Linear(64, 1)  # 输出负载数值，或者分3类        )        # 4. PGFA (Physics-Guided Frequency Attention)        # 这是一个动态掩膜，在 forward 里生成        self.pgfa_scale = nn.Parameter(torch.tensor(0.5))  # 可学习强度        # 5. 主分类头        self.cls_head = nn.Sequential(            nn.BatchNorm1d(256),  # 128+128            nn.Dropout(0.3),            nn.Linear(256, num_classes)        )    def forward(self, x, speed):        # x: [B, L, D] (Magnitude Spectrum)        # speed: [B, 1] (RPM)        x = self.revin(x, 'norm')        # 分解        res, trend = self.decomp(x)        # res = Seasonal (Peaks), trend = Trend (Envelope)        # === PGFA 模块 ===        # 生成物理掩膜 mask: [B, L, 1]        mask = self._generate_pgfa_mask(speed)        # 施加物理引导: 增强关键频率        res_guided = res * (1 + self.pgfa_scale * mask)        # 特征提取        # [B, L, 1] -> [B, L] -> Linear -> [B, 128]        feat_trend = self.linear_trend(trend.squeeze(-1))        feat_seasonal = self.linear_seasonal(res_guided.squeeze(-1))        # 融合        feat_fusion = torch.cat([feat_trend, feat_seasonal], dim=1)  # [B, 256]        # 输出        logits_cls = self.cls_head(feat_fusion)  # 故障分类        pred_load = self.load_head(feat_trend)  # 负载回归 (辅助任务)        return logits_cls, pred_load    def _generate_pgfa_mask(self, speed):        # speed: [B, 1] RPM        B = speed.shape[0]        L = self.seq_len        device = speed.device        # 频率轴 (0 ~ Fs/2)        # 假设 Fs=51200, L=1024 ->分辨率 df = 25Hz (需确认FFT参数)        # 建议预计算好 freq_bins        freqs = torch.linspace(0, 25600, L).to(device)  # [L]        masks = []        for i in range(B):            fr = speed[i] / 60.0  # 转频 Hz            # 1. 转子动力学: fr, 2fr, 3fr            m_rotor = torch.exp(-0.5 * (freqs - fr) ** 2 / 100) + \                      torch.exp(-0.5 * (freqs - 2 * fr) ** 2 / 100)            # 2. 结构损伤 (轴承): 高频带 > 10fr            # 简单用 sigmoid 模拟高通            m_structure = torch.sigmoid((freqs - 10 * fr) / 50)            # 3. 组合            m_total = m_rotor + m_structure            masks.append(m_total)        return torch.stack(masks).unsqueeze(-1)  # [B, L, 1]# 记得把 RevIN 和 SeriesDecomp 引用过来from models.layers import RevIN, SeriesDecomp