import torchimport torch.nn as nnfrom models.layers import RevIN, SeriesDecomp  # 复用第三章骨干class PhysRDLinearCls(nn.Module):    def __init__(self, num_classes=8, freq_dim=512):        super().__init__()        # 1. 频域 RevIN：消除变工况幅值漂移        self.revin = RevIN(num_features=1, affine=True)        self.decomp = SeriesDecomp(kernel_size=25)        # 2. 诊断分支        self.linear_trend = nn.Linear(freq_dim, 128)        self.linear_seasonal = nn.Linear(freq_dim, 128)        # 3. 物理引导注意力 (PGFA)：动态锁定转频        self.pgfa_strength = nn.Parameter(torch.tensor(0.5))        # 4. 虚拟负载传感器 (辅助任务)        self.load_head = nn.Sequential(            nn.Linear(128, 1)  # 输出连续负载值，实现工况解耦        )        # 5. 故障分类头 (主任务)        self.cls_head = nn.Sequential(            nn.Linear(256, num_classes)        )    def forward(self, x, speed_hz):        """        x: [B, L, 1] 频域谱线        speed_hz: [B, 1] 实时转频协变量        """        # A. 频域归一化        x = self.revin(x, 'norm')        # B. 线性分解：Trend(包络) vs Seasonal(谱线)        seasonal, trend = self.decomp(x)        # C. PGFA：物理引导掩码生成 (向量化实现，禁止循环)        mask = self._build_physics_mask(speed_hz, x.device, x.shape[1])        # 物理引导注入：增强转频及其倍频分量        seasonal_guided = seasonal * (1 + self.pgfa_strength * mask)        # D. 特征聚合        t_feat = self.linear_trend(trend.squeeze(-1))        s_feat = self.linear_seasonal(seasonal_guided.squeeze(-1))        fusion_feat = torch.cat([t_feat, s_feat], dim=1)        # E. 多任务输出        logits = self.cls_head(fusion_feat)        pred_load = self.load_head(t_feat)  # 趋势分支负责感知工况        return logits, pred_load    def _build_physics_mask(self, speed_hz, device, length):        # 动态生成高斯掩码，锁定 1x, 2x 转频        freq_axis = torch.linspace(0, 500, length).to(device)  # 针对显微流        # 向量化计算高斯分布        mask = torch.exp(-0.5 * (freq_axis - speed_hz) ** 2 / 10.0) + \               torch.exp(-0.5 * (freq_axis - 2 * speed_hz) ** 2 / 10.0)        return mask.unsqueeze(-1)