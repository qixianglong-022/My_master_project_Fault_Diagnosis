import torchimport torch.nn as nnclass PGFA(nn.Module):    """    物理引导频域注意力 (Physics-Guided Frequency Attention)    核心：根据物理转速 f_r，在频域生成动态高斯掩膜，显式锁定故障特征区间。    """    def __init__(self, freq_dim: int, max_freq: float = 512.0, sigma: float = 2.0):        super().__init__()        self.sigma = sigma        # 可学习的物理增益系数，初始为0.1避免初期干扰太大        self.alpha = nn.Parameter(torch.tensor(0.2))        # 注册频率轴 [0, ..., 512] Hz        # shape: [1, 512, 1] 方便广播        self.register_buffer('freq_axis', torch.linspace(0, max_freq, freq_dim).view(1, -1, 1))    def forward(self, seasonal: torch.Tensor, speed_hz: torch.Tensor) -> torch.Tensor:        """        seasonal: [B, F, 1]        speed_hz: [B, 1] (真实物理频率 Hz)        """        # 扩展转速维度 [B, 1] -> [B, 1, 1]        s = speed_hz.view(-1, 1, 1)        f = self.freq_axis        # 生成动态物理掩膜 (Mask)        # 关注基频、二倍频、三倍频 (可根据故障机理扩展)        denom = 2 * (self.sigma ** 2)        mask = torch.exp(- (f - s) ** 2 / denom) + \               torch.exp(- (f - 2 * s) ** 2 / denom) + \               torch.exp(- (f - 3 * s) ** 2 / denom)        # 哈达玛积注入 + 残差连接        # seasonal * (1 + alpha * mask)        # 当 mask 高时，该频段特征被放大        return seasonal * (1 + self.alpha * mask)class PhysRDLinearCls(nn.Module):    def __init__(self, config, enable_pgfa=True, enable_mtl=True, enable_acoustic=True):        super().__init__()        self.enable_pgfa = enable_pgfa        self.enable_mtl = enable_mtl        self.enable_acoustic = enable_acoustic        # --- 1. Low-Freq Micro Stream (物理分辨率增强流) ---        self.revin_micro = nn.BatchNorm1d(config.FREQ_DIM, affine=False)  # 频域归一化简化版        self.decomp = SeriesDecomp(kernel_size=25)  # 简单MA分解        if self.enable_pgfa:            self.pgfa = PGFA(freq_dim=config.FREQ_DIM, max_freq=512.0, sigma=config.PGFA_SIGMA)        self.lin_trend = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        self.lin_sea = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # --- 2. High-Freq Macro Stream (全景宽带流) ---        self.revin_macro = nn.BatchNorm1d(config.FREQ_DIM, affine=False)        self.lin_macro = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # --- 3. Acoustic Stream (声纹流) ---        if self.enable_acoustic:            self.acoustic_head = nn.Sequential(                nn.Linear(26, 64),                nn.ReLU(),                nn.Linear(64, config.HIDDEN_DIM)            )        # --- Fusion & Heads ---        # 融合后的维度        fusion_dim = config.HIDDEN_DIM * 3 + (config.HIDDEN_DIM if self.enable_acoustic else 0)        self.cls_head = nn.Sequential(            nn.BatchNorm1d(fusion_dim),            nn.Linear(fusion_dim, config.HIDDEN_DIM),            nn.ReLU(),            nn.Dropout(0.4),  # 增加 Dropout 应对小样本            nn.Linear(config.HIDDEN_DIM, config.NUM_CLASSES)        )        if self.enable_mtl:            # 负载回归头：只看 Trend 分支 (解耦关键)            self.load_head = nn.Sequential(                nn.Linear(config.HIDDEN_DIM, 32),                nn.ReLU(),                nn.Linear(32, 1)  # 输出归一化负载 [0, 1]            )    def forward(self, x_micro, x_macro, x_acoustic, speed_hz):        # x_micro, x_macro: [B, 512, 1]        # --- Stream 1 Processing ---        # 1. Norm & Decomp        x_mic_norm = self.revin_micro(x_micro.squeeze(-1)).unsqueeze(-1)        sea, trend = self.decomp(x_mic_norm)        # 2. PGFA (Physics Injection)        if self.enable_pgfa:            sea = self.pgfa(sea, speed_hz)        # 3. Embedding        f_trend = self.lin_trend(trend.squeeze(-1))        f_sea = self.lin_sea(sea.squeeze(-1))        # --- Stream 2 Processing ---        x_mac_norm = self.revin_macro(x_macro.squeeze(-1)).unsqueeze(-1)        f_macro = self.lin_macro(x_mac_norm.squeeze(-1))        # --- Fusion ---        feats = [f_trend, f_sea, f_macro]        if self.enable_acoustic:            f_ac = self.acoustic_head(x_acoustic)            feats.append(f_ac)        fusion = torch.cat(feats, dim=1)        # --- Outputs ---        logits = self.cls_head(fusion)        pred_load = None        if self.enable_mtl:            pred_load = self.load_head(f_trend)  # Trend 分支吸附负载        return logits, pred_load# 辅助类：简单的分解class SeriesDecomp(nn.Module):    def __init__(self, kernel_size):        super().__init__()        self.avg = nn.AvgPool1d(kernel_size=kernel_size, stride=1, padding=kernel_size // 2)    def forward(self, x):        # x: [B, L, 1] -> [B, 1, L]        x_t = x.permute(0, 2, 1)        trend = self.avg(x_t).permute(0, 2, 1)        sea = x - trend        return sea, trend