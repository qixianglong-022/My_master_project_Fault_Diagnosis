# models/phys_rdlinear.pyimport torchimport torch.nn as nnfrom models.layers import SeriesDecomp  # 复用你的 layersclass PGFA(nn.Module):    """    [物理层修正] 物理引导频域注意力    修改点：    1. 增加 Sideband Mask (转子断条特征: 1x ± 2s*f_grid)       注：由于 slip s 很难实时估算，这里简化为关注 50Hz (工频) 附近的边带。       或者更通用的：关注低频段的密集谐波。    2. 引入可学习的带宽 sigma。    """    def __init__(self, freq_dim: int, max_freq: float = 512.0, init_sigma: float = 2.0):        super().__init__()        # 让 sigma 可学习，允许模型自己调整“关注窗口”的宽窄        self.sigma = nn.Parameter(torch.tensor(init_sigma))        self.alpha = nn.Parameter(torch.tensor(0.5))        # 频率轴: [1, 512, 1]        self.register_buffer('freq_axis', torch.linspace(0, max_freq, freq_dim).view(1, -1, 1))    def forward(self, seasonal: torch.Tensor, speed_hz: torch.Tensor) -> torch.Tensor:        """        seasonal: [B, F, 1]        speed_hz: [B, 1]        """        s = speed_hz.view(-1, 1, 1)  # 基频        f = self.freq_axis        # 限制 sigma 不为负且不过大        sig = torch.clamp(self.sigma, min=0.5, max=10.0)        denom = 2 * (sig ** 2)        # 1. 机械谐波 (1x, 2x, 3x): 这一部分你写得很对！        mask_harmonics = torch.exp(- (f - s) ** 2 / denom) + \                         torch.exp(- (f - 2 * s) ** 2 / denom) + \                         torch.exp(- (f - 3 * s) ** 2 / denom)        # 2. [修改点] 将硬编码的 10Hz 改为 "0.5倍转频" (Sub-harmonic)        # 物理含义：0.5x 通常对应机械松动 (Looseness) 或 摩擦 (Rubbing)，        # 这是低频段除了 1x 以外最重要的随转速变化的特征。        # 相比于写死的 10Hz，这才是真正的 "Physics-Guided"。        mask_sub = torch.exp(- (f - 0.5 * s) ** 2 / denom) * 0.5        # 或者，如果你确实想保留一个极低频的底噪关注（比如 0~5Hz），        # 应该设中心为 0，而不是 10。        # mask_dc = torch.exp(- (f - 0) ** 2 / (2 * 5.0**2)) * 0.3        total_mask = mask_harmonics + mask_sub  # + mask_dc (可选)        # 哈达玛积注入        return seasonal * (1 + self.alpha * total_mask)class PhysRDLinearCls(nn.Module):    def __init__(self, config, enable_pgfa=True, enable_mtl=True, enable_acoustic=True):        super().__init__()        self.enable_pgfa = enable_pgfa        self.enable_mtl = enable_mtl        self.enable_acoustic = enable_acoustic        # === 1. Micro Stream (1Hz Res) ===        # 频域 RevIN: 消除幅值漂移        self.revin_micro = nn.BatchNorm1d(config.FREQ_DIM, affine=False)        self.decomp = SeriesDecomp(kernel_size=25)        if self.enable_pgfa:            # max_freq 必须是 512.0 (对应 config.SAMPLE_RATE/2)            self.pgfa = PGFA(config.FREQ_DIM, max_freq=config.SAMPLE_RATE / 2, sigma=config.PGFA_SIGMA)        self.lin_trend = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        self.lin_sea = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # === 2. Macro Stream (50Hz Res) ===        self.revin_macro = nn.BatchNorm1d(config.FREQ_DIM, affine=False)        self.lin_macro = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # === 3. Acoustic ===        if self.enable_acoustic:            self.ac_head = nn.Sequential(                nn.Linear(26, 64),                nn.ReLU(),                nn.Linear(64, config.HIDDEN_DIM)            )        # === Fusion ===        # D_trend + D_sea + D_macro + (D_ac)        fusion_dim = config.HIDDEN_DIM * 3 + (config.HIDDEN_DIM if self.enable_acoustic else 0)        self.cls_head = nn.Sequential(            nn.BatchNorm1d(fusion_dim),            nn.Linear(fusion_dim, config.HIDDEN_DIM),            nn.ReLU(),            nn.Dropout(0.5),  # 增加Dropout防止过拟合源域            nn.Linear(config.HIDDEN_DIM, config.NUM_CLASSES)        )        # === Virtual Load Sensor (MTL) ===        if self.enable_mtl:            # 仅从 Trend 分支回归负载 (强制 Trend 吸附工况信息)            self.load_head = nn.Sequential(                nn.Linear(config.HIDDEN_DIM, 32),                nn.ReLU(),                nn.Linear(32, 1)  # Output normalized load [0, 1]            )    def forward(self, micro, macro, acoustic, speed):        # micro: [B, 512, 1]        # --- Micro Path ---        # 1. Norm        mic_norm = self.revin_micro(micro.squeeze(-1)).unsqueeze(-1)        # 2. Decomp        sea, trend = self.decomp(mic_norm)        # 3. PGFA        if self.enable_pgfa:            sea = self.pgfa(sea, speed)        f_trend = self.lin_trend(trend.squeeze(-1))        f_sea = self.lin_sea(sea.squeeze(-1))        # --- Macro Path ---        mac_norm = self.revin_macro(macro.squeeze(-1))        f_macro = self.lin_macro(mac_norm)        # --- Acoustic Path ---        feats = [f_trend, f_sea, f_macro]        if self.enable_acoustic:            f_ac = self.ac_head(acoustic)            feats.append(f_ac)        # --- Fusion ---        fusion = torch.cat(feats, dim=1)        logits = self.cls_head(fusion)        # --- MTL ---        pred_load = None        if self.enable_mtl:            pred_load = self.load_head(f_trend)        return logits, pred_load