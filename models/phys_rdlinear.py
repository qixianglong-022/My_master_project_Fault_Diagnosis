# models/phys_rdlinear.pyimport torchimport torch.nn as nnfrom models.layers import SeriesDecompclass FreqRevIN(nn.Module):    """频域 RevIN (保持不变)"""    # ... (代码保持不变) ...    def __init__(self, num_features: int, eps=1e-5, affine=True):        super().__init__()        self.num_features = num_features        self.eps = eps        self.affine = affine        if self.affine:            self.affine_weight = nn.Parameter(torch.ones(1, num_features, 1))            self.affine_bias = nn.Parameter(torch.zeros(1, num_features, 1))    def forward(self, x, mode='norm'):        if mode == 'norm':            self.mean = torch.mean(x, dim=1, keepdim=True).detach()            self.stdev = torch.sqrt(torch.var(x, dim=1, keepdim=True, unbiased=False) + self.eps).detach()            x = (x - self.mean) / self.stdev            if self.affine:                x = x * self.affine_weight + self.affine_bias            return x        elif mode == 'denorm':            # 分类任务通常不需要 denorm，但为了完整性保留            return x        return xclass PGFA(nn.Module):    """物理引导频域注意力 (保持不变)"""    # ... (代码保持不变) ...    def __init__(self, freq_dim: int, max_freq: float = 512.0, init_sigma: float = 2.0):        super().__init__()        self.sigma = nn.Parameter(torch.tensor(init_sigma))        self.alpha = nn.Parameter(torch.tensor(0.5))        self.register_buffer('freq_axis', torch.linspace(0, max_freq, freq_dim).view(1, -1, 1))    def forward(self, seasonal: torch.Tensor, speed_hz: torch.Tensor) -> torch.Tensor:        s = speed_hz.view(-1, 1, 1)        f = self.freq_axis        sig = torch.clamp(self.sigma, min=0.5, max=10.0)        denom = 2 * (sig ** 2)        mask_harmonics = torch.exp(- (f - s) ** 2 / denom) + \                         torch.exp(- (f - 2 * s) ** 2 / denom) + \                         torch.exp(- (f - 3 * s) ** 2 / denom)        mask_sub = torch.exp(- (f - 0.5 * s) ** 2 / denom) * 0.5        total_mask = mask_harmonics + mask_sub        return seasonal * (1 + self.alpha * total_mask)# ================= [NEW] 自适应融合模块 (Section 4.3.4) =================class AdaptiveFusion(nn.Module):    def __init__(self, hidden_dim, dropout=0.1):        super().__init__()        # Input: Covariates [Speed, Load] -> 2 dim        # Output: Weights for [Vib, Audio, Current] -> 3 dim        self.weight_net = nn.Sequential(            nn.Linear(2, 16),            nn.ReLU(),            nn.Linear(16, 3)        )        self.softmax = nn.Softmax(dim=1)    def forward(self, h_vib, h_aud, h_cur, speed, load):        # 拼接协变量 [B, 2]        cov = torch.cat([speed, load], dim=1)        # 计算动态权重        weights = self.softmax(self.weight_net(cov))  # [B, 3]        w_vib = weights[:, 0:1]        w_aud = weights[:, 1:2]        w_cur = weights[:, 2:3]        # 加权求和        fused = w_vib * h_vib + w_aud * h_aud + w_cur * h_cur        return fused, weightsclass PhysRDLinearCls(nn.Module):    def __init__(self, config, enable_pgfa=True, enable_mtl=True):        """        V2 Update:        - 移除 load_head (MTL回归)        - 增加 Current 分支        - 增加 Trend 协变量注入        - 增加 AdaptiveFusion        """        super().__init__()        self.enable_pgfa = enable_pgfa        # === 1. Vibration Stream (Micro) ===        self.revin_micro = FreqRevIN(config.FREQ_DIM, affine=False)        self.decomp = SeriesDecomp(kernel_size=25)        if self.enable_pgfa:            self.pgfa = PGFA(config.FREQ_DIM, max_freq=config.SAMPLE_RATE / 2, init_sigma=config.PGFA_SIGMA)        # 特征映射层        self.feat_vib = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # === 2. Macro Stream (作为 Vib 的补充，这里简化处理，将其合并进 Vib 或独立) ===        # 为了适配 AdaptiveFusion 的三模态结构，我们将 Micro+Macro 视为 "Vib" 模态        self.revin_macro = FreqRevIN(config.FREQ_DIM, affine=False)        self.feat_macro = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # Vib 融合层: Micro + Macro -> Vib Feature        self.vib_proj = nn.Linear(config.HIDDEN_DIM * 2, config.HIDDEN_DIM)        # === 3. Audio Stream ===        self.feat_aud = nn.Sequential(            nn.Linear(config.AUDIO_DIM, 64),            nn.ReLU(),            nn.Linear(64, config.HIDDEN_DIM)        )        # === 4. Current Stream [NEW] ===        self.feat_cur = nn.Sequential(            nn.Linear(config.CURRENT_DIM, 64),            nn.ReLU(),            nn.Linear(64, config.HIDDEN_DIM)        )        # === 5. Trend Branch (Covariate-Driven) [NEW] ===        # Trend 物理上由 Speed 和 Load 决定        # 输入: Trend_Vib (from Decomp) + Speed + Load        self.trend_proj = nn.Sequential(            nn.Linear(config.FREQ_DIM + 2, config.HIDDEN_DIM),  # +2 for Speed, Load            nn.ReLU(),            nn.Dropout(0.3)        )        # === 6. Seasonal Branch (Adaptive Fusion) [NEW] ===        self.fusion_layer = AdaptiveFusion(config.HIDDEN_DIM)        # === 7. Classifier ===        # Input: Trend (Condition) + Seasonal (Fault)        self.cls_head = nn.Sequential(            nn.BatchNorm1d(config.HIDDEN_DIM * 2),            nn.Linear(config.HIDDEN_DIM * 2, config.HIDDEN_DIM),            nn.ReLU(),            nn.Dropout(0.5),            nn.Linear(config.HIDDEN_DIM, config.NUM_CLASSES)        )    def forward(self, micro, macro, acoustic, current, speed, load):        # --- A. Vibration Processing ---        # 1. Micro: RevIN -> Decomp -> PGFA        mic_norm = self.revin_micro(micro, 'norm')        sea_mic, trend_mic = self.decomp(mic_norm)  # [B, F, 1]        if self.enable_pgfa:            sea_mic = self.pgfa(sea_mic, speed)        h_sea_mic = self.feat_vib(sea_mic.squeeze(-1))        # 2. Macro: RevIN -> Linear        mac_norm = self.revin_macro(macro, 'norm')        h_mac = self.feat_macro(mac_norm.squeeze(-1))        # 3. Combine to Vib Feature        h_vib = self.vib_proj(torch.cat([h_sea_mic, h_mac], dim=1))        # --- B. Other Modalities ---        h_aud = self.feat_aud(acoustic)        h_cur = self.feat_cur(current)        # --- C. Seasonal Branch: Adaptive Fusion ---        # 融合 Vib, Audio, Current，权重由 Speed/Load 决定        h_seasonal, weights = self.fusion_layer(h_vib, h_aud, h_cur, speed, load)        # --- D. Trend Branch: Covariate Injection ---        # Trend 部分显式拼接 Speed 和 Load，学习基线能量        # Trend_Mic 包含了振动的低频包络        trend_flat = trend_mic.squeeze(-1)        trend_input = torch.cat([trend_flat, speed, load], dim=1)        h_trend = self.trend_proj(trend_input)        # --- E. Final Classification ---        # 拼接 工况基线(Trend) 和 故障特征(Seasonal)        out_feat = torch.cat([h_trend, h_seasonal], dim=1)        logits = self.cls_head(out_feat)        return logits, weights  # 返回权重用于可视化