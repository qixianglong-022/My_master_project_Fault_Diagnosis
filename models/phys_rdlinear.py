import torchimport torch.nn as nnfrom typing import Tupleclass RevIN(nn.Module):    """频域 RevIN (保持不变)"""    def __init__(self, num_features: int, eps: float = 1e-5, affine: bool = True):        super().__init__()        self.num_features = num_features        self.eps = eps        self.affine = affine        if self.affine:            self.affine_weight = nn.Parameter(torch.ones(num_features))            self.affine_bias = nn.Parameter(torch.zeros(num_features))    def forward(self, x: torch.Tensor, mode: str) -> torch.Tensor:        if mode == 'norm':            self.mean = torch.mean(x, dim=1, keepdim=True).detach()            self.stdev = torch.sqrt(torch.var(x, dim=1, keepdim=True, unbiased=False) + self.eps).detach()            x = (x - self.mean) / self.stdev            if self.affine:                x = x * self.affine_weight + self.affine_bias            return x        return x  # Cls 任务不需要 denormclass SeriesDecomp(nn.Module):    """频域分解: Trend (包络) + Seasonal (谱峰)"""    def __init__(self, kernel_size: int = 25):        super().__init__()        # Padding 策略保证输出维度不变        self.avg = nn.AvgPool1d(kernel_size=kernel_size, stride=1, padding=kernel_size // 2, count_include_pad=False)    def forward(self, x: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:        # x: [B, L, 1] -> [B, 1, L]        x_t = x.permute(0, 2, 1)        trend = self.avg(x_t).permute(0, 2, 1)  # [B, L, 1]        seasonal = x - trend        return seasonal, trendclass PGFA(nn.Module):    """物理引导频域注意力 (保持不变，非常漂亮的代码)"""    def __init__(self, freq_dim: int, sigma: float = 3.0):        super().__init__()        self.sigma = sigma        self.alpha = nn.Parameter(torch.tensor(0.5))        # 假设 Micro 流对应 0-500Hz (降采样后)        self.register_buffer('freq_axis', torch.linspace(0, 500, freq_dim))    def forward(self, seasonal: torch.Tensor, speed_hz: torch.Tensor) -> torch.Tensor:        f = self.freq_axis.view(1, -1, 1)  # [1, L, 1]        s = speed_hz.view(-1, 1, 1)  # [B, 1, 1]        # 关注 1x, 2x, 3x 转频和谐波        mask = torch.exp(-0.5 * (f - s) ** 2 / self.sigma) + \               torch.exp(-0.5 * (f - 2 * s) ** 2 / self.sigma) + \               torch.exp(-0.5 * (f - 3 * s) ** 2 / self.sigma)        return seasonal * (1 + self.alpha * mask)class PhysRDLinearCls(nn.Module):    """    [重构版] 双流物理引导轻量化模型    Stream 1 (Micro): RevIN -> Decomp -> Trend(Load) + Seasonal(PGFA)    Stream 2 (Macro): RevIN -> Linear (捕捉高频共振带宽)    """    def __init__(self, config, enable_pgfa=True, enable_mtl=True):        super().__init__()        self.enable_pgfa = enable_pgfa        self.enable_mtl = enable_mtl        # --- Stream 1: Micro (低频显微) ---        self.revin_micro = RevIN(num_features=1)        self.decomp = SeriesDecomp(kernel_size=25)        # [Ablation] 只有开启 PGFA 才初始化该模块        if self.enable_pgfa:            self.pgfa = PGFA(freq_dim=config.FREQ_DIM, sigma=config.PGFA_SIGMA)        self.lin_trend = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        self.lin_sea = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # --- Stream 2: Macro (高频全景) ---        self.revin_macro = RevIN(num_features=1)        # Macro流不需要分解，主要看能量带分布        self.lin_macro = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # --- Heads ---        # Task A: 虚拟负载回归 (只用 Trend)        if self.enable_mtl:            self.load_head = nn.Sequential(                nn.Linear(config.HIDDEN_DIM, 64),                nn.ReLU(),                nn.Linear(64, 1)            )        # Task B: 故障分类 (融合特征)        # 输入维度: Trend + Seasonal + Macro = 3 * Hidden        self.cls_head = nn.Sequential(            nn.Linear(config.HIDDEN_DIM * 3, config.HIDDEN_DIM),            nn.ReLU(),            nn.Dropout(0.2),            nn.Linear(config.HIDDEN_DIM, config.NUM_CLASSES)        )    def forward(self, x_micro, x_macro, speed_hz):        # --- Stream 1 ---        x_micro = self.revin_micro(x_micro, 'norm')        sea, trend = self.decomp(x_micro)        # [Ablation] PGFA 逻辑        if self.enable_pgfa:            sea_guided = self.pgfa(sea, speed_hz)        else:            sea_guided = sea  # 如果禁用，直接透传，退化为普通残差        feat_trend = self.lin_trend(trend.squeeze(-1))        feat_sea = self.lin_sea(sea_guided.squeeze(-1))        # --- Stream 2 ---        x_macro = self.revin_macro(x_macro, 'norm')        feat_macro = self.lin_macro(x_macro.squeeze(-1))        # --- Task A: Load Regression ---        pred_load = None        if self.enable_mtl:            pred_load = self.load_head(feat_trend)        # --- Task B: Classification ---        fusion = torch.cat([feat_trend, feat_sea, feat_macro], dim=1)        logits = self.cls_head(fusion)        return logits, pred_load