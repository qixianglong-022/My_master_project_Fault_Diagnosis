# models/phys_rdlinear.pyimport torchimport torch.nn as nnfrom models.layers import SeriesDecomp  # 复用你的 layersclass PGFA(nn.Module):    """    [核心创新] 物理引导频域注意力    根据转速 f_r 生成多谐波高斯掩膜，强制模型关注故障特征频段    """    def __init__(self, freq_dim: int, max_freq: float = 512.0, sigma: float = 2.0):        super().__init__()        self.sigma = sigma        self.alpha = nn.Parameter(torch.tensor(0.2))  # 可学习的注入强度        # 注册频率轴 [0, ..., 512] Hz        # 对应 preprocess 中 target_fs/2        self.register_buffer('freq_axis', torch.linspace(0, max_freq, freq_dim).view(1, -1, 1))    def forward(self, seasonal: torch.Tensor, speed_hz: torch.Tensor) -> torch.Tensor:        """        seasonal: [B, F, 1]        speed_hz: [B, 1] (Real Hz, e.g., 15.0, 45.0)        """        s = speed_hz.view(-1, 1, 1)  # [B, 1, 1]        f = self.freq_axis  # [1, 512, 1]        # 多谐波掩膜: 1x, 2x, 3x (覆盖不对中、不平衡等基频故障)        denom = 2 * (self.sigma ** 2)        mask = torch.exp(- (f - s) ** 2 / denom) + \               torch.exp(- (f - 2 * s) ** 2 / denom) + \               torch.exp(- (f - 3 * s) ** 2 / denom)        # 简单归一化 mask 到 [0, 1]        mask = torch.clamp(mask, 0, 1)        # 残差注入        return seasonal * (1 + self.alpha * mask)class PhysRDLinearCls(nn.Module):    def __init__(self, config, enable_pgfa=True, enable_mtl=True, enable_acoustic=True):        super().__init__()        self.enable_pgfa = enable_pgfa        self.enable_mtl = enable_mtl        self.enable_acoustic = enable_acoustic        # === 1. Micro Stream (1Hz Res) ===        # 频域 RevIN: 消除幅值漂移        self.revin_micro = nn.BatchNorm1d(config.FREQ_DIM, affine=False)        self.decomp = SeriesDecomp(kernel_size=25)        if self.enable_pgfa:            # max_freq 必须是 512.0 (对应 config.SAMPLE_RATE/2)            self.pgfa = PGFA(config.FREQ_DIM, max_freq=config.SAMPLE_RATE / 2, sigma=config.PGFA_SIGMA)        self.lin_trend = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        self.lin_sea = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # === 2. Macro Stream (50Hz Res) ===        self.revin_macro = nn.BatchNorm1d(config.FREQ_DIM, affine=False)        self.lin_macro = nn.Linear(config.FREQ_DIM, config.HIDDEN_DIM)        # === 3. Acoustic ===        if self.enable_acoustic:            self.ac_head = nn.Sequential(                nn.Linear(26, 64),                nn.ReLU(),                nn.Linear(64, config.HIDDEN_DIM)            )        # === Fusion ===        # D_trend + D_sea + D_macro + (D_ac)        fusion_dim = config.HIDDEN_DIM * 3 + (config.HIDDEN_DIM if self.enable_acoustic else 0)        self.cls_head = nn.Sequential(            nn.BatchNorm1d(fusion_dim),            nn.Linear(fusion_dim, config.HIDDEN_DIM),            nn.ReLU(),            nn.Dropout(0.5),  # 增加Dropout防止过拟合源域            nn.Linear(config.HIDDEN_DIM, config.NUM_CLASSES)        )        # === Virtual Load Sensor (MTL) ===        if self.enable_mtl:            # 仅从 Trend 分支回归负载 (强制 Trend 吸附工况信息)            self.load_head = nn.Sequential(                nn.Linear(config.HIDDEN_DIM, 32),                nn.ReLU(),                nn.Linear(32, 1)  # Output normalized load [0, 1]            )    def forward(self, micro, macro, acoustic, speed):        # micro: [B, 512, 1]        # --- Micro Path ---        # 1. Norm        mic_norm = self.revin_micro(micro.squeeze(-1)).unsqueeze(-1)        # 2. Decomp        sea, trend = self.decomp(mic_norm)        # 3. PGFA        if self.enable_pgfa:            sea = self.pgfa(sea, speed)        f_trend = self.lin_trend(trend.squeeze(-1))        f_sea = self.lin_sea(sea.squeeze(-1))        # --- Macro Path ---        mac_norm = self.revin_macro(macro.squeeze(-1))        f_macro = self.lin_macro(mac_norm)        # --- Acoustic Path ---        feats = [f_trend, f_sea, f_macro]        if self.enable_acoustic:            f_ac = self.ac_head(acoustic)            feats.append(f_ac)        # --- Fusion ---        fusion = torch.cat(feats, dim=1)        logits = self.cls_head(fusion)        # --- MTL ---        pred_load = None        if self.enable_mtl:            pred_load = self.load_head(f_trend)        return logits, pred_load